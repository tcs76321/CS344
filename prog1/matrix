#!/bin/bash

dimsNstdN=0 # helper variable for seeing if we need to deal with cat piping and stdin, only used with dims because I did a streamlined version for some of the functions

datafilepath="datafileUno" # store string datafileUno as datafilepath variable
datafilepath2="datafileDos"

if [ "$#" = "1" ] && [ $1 == "dims" ] # check for if dims and being passed through stdin via piping or not
then
	dimsNstdN=3 # use helper variable, the number three is irrelevant, just not 0 now
	cat > "$datafilepath" # make a file basically, from that stdin stream
elif [ "$#" = "2" ] && [ $1 == "dims" ] # two arguements, so not stdin in any way and dims 
then
	datafilepath=$2
fi # this is taken care of automatically in the way I handle the rest

dims(){
	if [[ "$dimsNstdN" -eq 0 ]] # normal, not from stdin, was passed a file
	then
		if [[ "$#" -gt  1 ]] # check for too many arguements, 2 or more, no negative numbers, leaving 1, 0 sets dimsNstdN to !0 so only correct arguements from this
		then
			echo incorrect number of parameters 1>&2 # print error message to stderr
			rm -f ./datafileDos # clean up files
			rm -f ./datafileUno
			exit 1 # set exit code to not 0, 1 is general error, misc
		elif [[ -r "$1" ]] # check that single static file exists and is readable
		then
			rows=0 # simple iterator, for lines and columns
			columns=0
			while read myLine
			do 
				rows=`expr $rows + 1`
				for i in $myLine
				do
					columns=`expr $columns + 1` # count each individual number of the matrix,
				done
			done < $datafilepath
			columns=`expr $columns / $rows` # and then divide by rows, lines, to get actual columns
			echo "$rows" "$columns"
			rm -f ./datafileDos
			rm -f ./datafileUno
			exit 0
		else
			echo inaccessible file or some other issue with -r 1>&2
			rm -f ./datafileDos
			rm -f ./datafileUno
			exit 1
		fi
	else # the first one was for if not catted and then now this one below is designed for it
		if [[ "$#" -gt  2 ]] # 
		then
			echo incorrect number of parameters 1>&2 # print error message to stderr
			rm -f ./datafileUno
			rm -f ./datafileDos
			exit 1
		elif [[ -r "$datafilepath" ]]
		then
			rows=0
			columns=0
			while read myLine
			do 
				rows=`expr $rows + 1`
				for i in $myLine
				do
					columns=`expr $columns + 1` # count each individual number of the matrix,
				done
			done < $datafilepath
			columns=`expr $columns / $rows` # and then divide by rows, lines, to get actual columns
			echo "$rows" "$columns"
			rm -f ./datafileUno
			rm -f ./datafileDos
			exit 0
		else
			echo inaccessible file or some other issue with -r 1>&2
			rm -f ./datafileUno
			rm -f ./datafileDos
			exit 1
		fi
	fi
}

transpose(){
	if [[ "$#" -ne "1" ]]
	then
		echo yo incorrect number of parameters yo 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	elif [[ -r "$1" ]]
	then
# ----------------- getting dims start
		jj=0
		ii=0
		while read myLine
		do 
			jj=`expr $jj + 1`
			for iiii in $myLine
			do
				ii=`expr $ii + 1`
			done
		done < $1
		ii=`expr $ii / $jj`
		
		tempCol="tempcolfile"
		tempRow="temprowfile"

		indexH=1
		
		cut -f $indexH $1 > $tempCol
		indexH=`expr $indexH + 1`
		cat $tempCol | tr '\n' '\t' > $tempRow
		truncate -s-1 $tempRow
		echo >> $tempRow
		for (( ijk=1; ijk<${ii}; ijk++ ));
		do
			cut -f $indexH $1 > $tempCol
			cat $tempCol | tr '\n' '\t' >> $tempRow
			truncate -s-1 $tempRow
			echo >> $tempRow
			indexH=`expr $indexH + 1`
		done

		cat $tempRow
		
		rm -f ./tempcolfile
		rm -f ./temprowfile
		rm -f ./datafileDos
		rm -f ./datafileUno
		exit 0
	else
		echo inaccessible file or some other issue with -r or!!!! dimensions!!!! 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	fi
}

mean(){
	if [[ "$#" -ne "1" ]]
	then
		echo yo incorrect number of parameters yo 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	elif [[ -r "$1" ]]
	then
# ----------------- getting dims start
		jj=0
		ii=0
		while read myLine
		do 
			jj=`expr $jj + 1`
			for iiii in $myLine
			do
				ii=`expr $ii + 1`
			done
		done < $1
		ii=`expr $ii / $jj`
		
		tempCol="tempcolfile"
		tempRow="temprowfile"
		tempCol2="tempcol2file"

		indexH=1
		
		cut -f $indexH $1 > $tempCol
		indexH=`expr $indexH + 1`
		cat $tempCol | tr '\n' '\t' > $tempRow
		truncate -s-1 $tempRow
		echo >> $tempRow
		for (( ijk=1; ijk<${ii}; ijk++ ));
		do
			cut -f $indexH $1 > $tempCol
			cat $tempCol | tr '\n' '\t' >> $tempRow
			truncate -s-1 $tempRow
			echo >> $tempRow
			indexH=`expr $indexH + 1`
		done

		while read tLine
		do
			yt=0
			dri=0
			for mno in $tLine
			do
				yt=`expr $yt + $mno`
				dri=`expr $dri + 1`
			done

			if [[ "$yt" -gt "0" ]]
			then
				yt=$(( ( ( $yt + ( $dri / 2 ) ) / $dri ) ))
			else
				yt=$(( ( ( $yt - ( $dri / 2 ) ) / $dri ) ))
			fi

			echo "$yt" >> $tempCol2
		done < $tempRow
		
		cat $tempCol2 | tr '\n' '\t' > $tempRow
		truncate -s-1 $tempRow
		echo >> $tempRow
		cat $tempRow

		rm -f ./tempcolfile
		rm -f ./tempcol2file
		rm -f ./temprowfile
		rm -f ./datafileDos
		rm -f ./datafileUno
		exit 0
	else
		echo inaccessible file or some other issue with -r or!!!! dimensions!!!! 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	fi
}

add(){
	if [[ "$#" -ne 2 ]]
	then
		echo yoincorrectnumberofparametersyo 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	elif [[ -r "$1" ]] && [[ -r "$2" ]]
	then
# ----------------- getting dims start
		jj=0
		ii=0 
		while read myLine
		do 
			jj=`expr $jj + 1`
			for iiii in $myLine
			do
				ii=`expr $ii + 1`
			done
		done < $1
		ii=`expr $ii / $jj`


		jj2=0
		ii2=0 
		while read myLine2
		do 
			jj2=`expr $jj2 + 1`
			for iiii2 in $myLine2
			do
				ii2=`expr $ii2 + 1`
			done
		done < $2
		ii2=`expr $ii2 / $jj2`
# ----------------- gettings dims DONE
# -----------------------------------
# ------------------- checking dims
		if [[ "$ii" -ne "$ii2" ]] || [[ "$jj" -ne "$jj2" ]]
		then
			echo wrongs dims on add 1>&2
			rm -f ./datafileUno
			rm -f ./datafileDos
			exit 1
		fi
# ---------------------- Done with that

		cat $1 > "$datafilepath"
		cat $2 > "$datafilepath2"

		audiput=""

		while read var1 <&4 && read var2 <&5
		do
			audiput=""
			pleaseGod=0
			for ia in $var1
			do
				pleaseGod2=0
				for ib in $var2
				do
					if [[ "$pleaseGod" -eq "$pleaseGod2" ]]
					then
						aaa=0
						aaa=`expr $ia + $ib`
						audiput="${audiput}$aaa\t"
						break
					fi
					pleaseGod2=$((pleaseGod2+1))
				done
				pleaseGod=$((pleaseGod+1))
			done
			audiput=${audiput%?}
			audiput=${audiput%?}
			echo -e "$audiput"
		done 4<datafileUno 5<datafileDos
		
		rm -f ./datafileDos
		rm -f ./datafileUno
		exit 0
	else
		echo inaccessible file or some other issue with -r or!!!! dimensions!!!! 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	fi
}

multiply(){
	if [[ "$#" -ne 2 ]] # check correct number of arguements
	then
		echo yoincorrectnumberofparametersyo 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	elif [[ -r "$1" ]] && [[ -r "$2" ]]
	then
# ----------------- getting dims start
		jj=0
		ii=0
		while read myLine
		do 
			jj=`expr $jj + 1`
			for iiii in $myLine
			do
				ii=`expr $ii + 1`
			done
		done < $1
		ii=`expr $ii / $jj`


		jj2=0
		ii2=0
		while read myLine2
		do 
			jj2=`expr $jj2 + 1`
			for iiii2 in $myLine2
			do
				ii2=`expr $ii2 + 1`
			done
		done < $2
		ii2=`expr $ii2 / $jj2`
# ----------------- gettings dims DONE
# -----------------------------------
# ------------------- checking dims for multiplication
		if [[ "$ii" -ne "$jj2" ]]
		then
			echo wrongs dims on multiply 1>&2
			rm -f ./datafileUno
			rm -f ./datafileDos
			exit 1
		fi
# ---------------------- Done with that

		
		arrayofA=()
		
		while read myLine
		do 
			for iiii in $myLine
			do
				arrayofA+=("$iiii")
			done
		done < $1

		
		arrayofB=()
		
		while read myLine
		do 
			for iiii in $myLine
			do
				arrayofB+=("$iiii")
			done
		done < $2
		
		echo $arrayofA
		echo $arrayofB
		
		rm -f ./datafileDos
		rm -f ./datafileUno
		exit 0
	else
		echo inaccessible file or some other issue with -r or!!!! dimensions!!!! 1>&2
		rm -f ./datafileUno
		rm -f ./datafileDos
		exit 1
	fi
}

"${@}"
#$1 "${@:2}
